// Copyright The Linux Foundation and each contributor to LFX.
// SPDX-License-Identifier: MIT

import { CommonModule } from '@angular/common';
import { Component, computed, DestroyRef, inject, input, OnInit, signal } from '@angular/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { FormGroup, ReactiveFormsModule, Validators } from '@angular/forms';
import { ButtonComponent } from '@components/button/button.component';
import { CalendarComponent } from '@components/calendar/calendar.component';
import { InputTextComponent } from '@components/input-text/input-text.component';
import { SelectComponent } from '@components/select/select.component';
import { TextareaComponent } from '@components/textarea/textarea.component';
import { TimePickerComponent } from '@components/time-picker/time-picker.component';
import { ToggleComponent } from '@components/toggle/toggle.component';
import { TIMEZONES } from '@lfx-pcc/shared/constants';
import { MeetingType } from '@lfx-pcc/shared/enums';
import { TooltipModule } from 'primeng/tooltip';

@Component({
  selector: 'lfx-meeting-details',
  standalone: true,
  imports: [
    CommonModule,
    ReactiveFormsModule,
    ButtonComponent,
    CalendarComponent,
    InputTextComponent,
    SelectComponent,
    TextareaComponent,
    TimePickerComponent,
    ToggleComponent,
    TooltipModule,
  ],
  templateUrl: './meeting-details.component.html',
})
export class MeetingDetailsComponent implements OnInit {
  // Form group input from parent
  public readonly form = input.required<FormGroup>();

  // Dependency injection
  private readonly destroyRef = inject(DestroyRef);

  // AI Agenda Helper signals
  public readonly showAiHelper = signal<boolean>(false);
  public readonly isGeneratingAgenda = signal<boolean>(false);

  // Auto-title generation signals
  public readonly titleWasAutoGenerated = signal<boolean>(false);

  // Duration options for the select dropdown
  public readonly durationOptions = [
    { label: '15 minutes', value: 15 },
    { label: '30 minutes', value: 30 },
    { label: '60 minutes', value: 60 },
    { label: '90 minutes', value: 90 },
    { label: '120 minutes', value: 120 },
    { label: 'Custom...', value: 'custom' },
  ];

  // Recurrence options (dynamically updated based on selected date)
  public recurrenceOptions = signal<Array<{ label: string; value: string }>>([]);

  // Timezone options from shared constants
  public readonly timezoneOptions = TIMEZONES.map((tz) => ({
    label: `${tz.label} (${tz.offset})`,
    value: tz.value,
  }));

  // Minimum date (yesterday)
  public readonly minDate = computed(() => {
    const yesterday = new Date();
    yesterday.setDate(yesterday.getDate() - 1);
    yesterday.setHours(0, 0, 0, 0);
    return yesterday;
  });

  public ngOnInit(): void {
    // Initialize recurrence options with current start date
    const initialStartDate = this.form().get('startDate')?.value;
    if (initialStartDate) {
      this.generateRecurrenceOptions(initialStartDate);
    } else {
      this.recurrenceOptions.set([{ label: 'Does not repeat', value: 'none' }]);
    }

    // Add custom duration validator when duration is 'custom'
    this.form()
      .get('duration')
      ?.valueChanges.pipe(takeUntilDestroyed(this.destroyRef))
      .subscribe((value) => {
        const customDurationControl = this.form().get('customDuration');
        if (value === 'custom') {
          customDurationControl?.setValidators([Validators.required, Validators.min(5), Validators.max(480)]);
        } else {
          customDurationControl?.clearValidators();
        }
        customDurationControl?.updateValueAndValidity();
      });

    // Reset recurrence selection when start date changes
    this.form()
      .get('startDate')
      ?.valueChanges.pipe(takeUntilDestroyed(this.destroyRef))
      .subscribe((value) => {
        // Reset recurrence to 'none' when date changes to avoid confusion
        this.form().get('recurrence')?.setValue('none');
        this.generateRecurrenceOptions(value as Date);
      });

    // Auto-generate title when meeting type and date are available
    this.form()
      .get('startDate')
      ?.valueChanges.pipe(takeUntilDestroyed(this.destroyRef))
      .subscribe(() => {
        this.generateMeetingTitleIfNeeded();
      });

    // Watch for isRecurring changes to reset recurrence
    this.form()
      .get('isRecurring')
      ?.valueChanges.pipe(takeUntilDestroyed(this.destroyRef))
      .subscribe((isRecurring) => {
        if (!isRecurring) {
          this.form().get('recurrence')?.setValue('none');
        } else {
          const recurrence = this.form().get('recurrence')?.value;
          if (!recurrence || recurrence === 'none') {
            this.form().get('recurrence')?.setValue('weekly');
          }
        }
      });
  }

  // AI Helper public methods
  public showAiAgendaHelper(): void {
    this.showAiHelper.set(true);
  }

  public hideAiAgendaHelper(): void {
    this.showAiHelper.set(false);
    this.form().get('aiPrompt')?.setValue('');
  }

  public async generateAiAgenda(): Promise<void> {
    const promptValue = this.form().get('aiPrompt')?.value;
    if (!promptValue?.trim()) return;

    this.isGeneratingAgenda.set(true);

    // Simulate API call delay
    await new Promise((resolve) => setTimeout(resolve, 2500));

    const meetingType = this.form().get('meeting_type')?.value || MeetingType.OTHER;
    const generatedAgenda = this.getMockAgenda(meetingType, promptValue);

    this.form().get('agenda')?.setValue(generatedAgenda);
    this.isGeneratingAgenda.set(false);
    this.hideAiAgendaHelper();
  }

  private generateRecurrenceOptions(date: Date): void {
    const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
    const dayName = dayNames[date.getDay()];

    // Calculate which occurrence of the day in the month (1st, 2nd, 3rd, 4th, or last)
    const { weekOfMonth, isLastWeek } = this.getWeekOfMonth(date);
    const ordinals = ['', '1st', '2nd', '3rd', '4th'];
    const ordinal = ordinals[weekOfMonth] || `${weekOfMonth}th`;

    const options = [
      { label: 'Daily', value: 'daily' },
      { label: `Weekly on ${dayName}`, value: 'weekly' },
      { label: 'Every weekday', value: 'weekdays' },
    ];

    // If this is the last occurrence, show "Monthly on the last [day]" instead of "Monthly on the Nth [day]"
    if (isLastWeek) {
      options.splice(3, 0, { label: `Monthly on the last ${dayName}`, value: 'monthly_last' });
    } else {
      options.splice(3, 0, { label: `Monthly on the ${ordinal} ${dayName}`, value: 'monthly_nth' });
    }

    this.recurrenceOptions.set(options);
  }

  private getWeekOfMonth(date: Date): { weekOfMonth: number; isLastWeek: boolean } {
    // Find the first occurrence of this day of week in the month
    const targetDayOfWeek = date.getDay();
    let firstOccurrence = 1;
    while (new Date(date.getFullYear(), date.getMonth(), firstOccurrence).getDay() !== targetDayOfWeek) {
      firstOccurrence++;
    }

    // Calculate which week this date is in
    const weekOfMonth = Math.floor((date.getDate() - firstOccurrence) / 7) + 1;

    // Check if this is the last occurrence of this day in the month
    const nextWeekDate = new Date(date.getTime() + 7 * 24 * 60 * 60 * 1000);
    const isLastWeek = nextWeekDate.getMonth() !== date.getMonth();

    return { weekOfMonth, isLastWeek };
  }

  // Auto-title generation
  private generateMeetingTitleIfNeeded(): void {
    const meetingType = this.form().get('meeting_type')?.value;
    const startDate = this.form().get('startDate')?.value;
    const currentTitle = this.form().get('topic')?.value;

    // Only auto-generate if we have both type and date, and the current title is empty or was auto-generated
    if (meetingType && startDate && (!currentTitle || this.titleWasAutoGenerated())) {
      const newTitle = this.generateMeetingTitle(meetingType, startDate);
      this.form().get('topic')?.setValue(newTitle);
      this.titleWasAutoGenerated.set(true);
    }
  }

  private generateMeetingTitle(meetingType: string, date: Date): string {
    const formattedDate = new Date(date).toLocaleDateString('en-US', {
      month: '2-digit',
      day: '2-digit',
      year: 'numeric',
    });

    return `${meetingType} Meeting - ${formattedDate}`;
  }

  private getMockAgenda(meetingType: string, prompt: string): string {
    const mockAgendas: Record<string, string> = {
      [MeetingType.BOARD]: `**Meeting Objective**: ${prompt}

**Agenda Items**:
1. **Opening & Welcome** (5 min)
   - Roll call and attendance
   - Review of previous meeting minutes

2. **Strategic Discussion** (25 min)
   - ${prompt}
   - Financial overview and budget considerations
   - Key performance indicators review

3. **Decision Items** (15 min)
   - Action items requiring board approval
   - Risk assessment and mitigation strategies

4. **Next Steps & Closing** (5 min)
   - Assignment of action items
   - Next meeting date confirmation`,

      [MeetingType.TECHNICAL]: `**Development Focus**: ${prompt}

**Technical Agenda**:
1. **System Status Review** (10 min)
   - Current sprint progress
   - Infrastructure health check

2. **Core Discussion** (30 min)
   - ${prompt}
   - Technical implementation approach
   - Architecture considerations and trade-offs

3. **Code Review & Quality** (15 min)
   - Recent pull requests and code changes
   - Testing coverage and quality metrics

4. **Planning & Blockers** (5 min)
   - Upcoming milestones
   - Technical blockers and dependencies`,

      [MeetingType.MAINTAINERS]: `**Community Focus**: ${prompt}

**Maintainers Sync Agenda**:
1. **Community Updates** (10 min)
   - Recent contributor activity
   - Community feedback highlights

2. **Project Discussion** (25 min)
   - ${prompt}
   - Release planning and roadmap updates
   - Contributor onboarding improvements

3. **Issue Triage** (20 min)
   - High-priority issues review
   - Feature requests evaluation

4. **Action Planning** (5 min)
   - Task assignments and next steps`,

      [MeetingType.MARKETING]: `**Marketing Initiative**: ${prompt}

**Marketing Meeting Agenda**:
1. **Performance Review** (10 min)
   - Current campaign metrics
   - Community growth statistics

2. **Strategic Focus** (25 min)
   - ${prompt}
   - Brand positioning and messaging
   - Content strategy alignment

3. **Campaign Planning** (20 min)
   - Upcoming marketing initiatives
   - Budget allocation and resources

4. **Collaboration & Next Steps** (5 min)
   - Cross-team coordination
   - Action item assignments`,

      [MeetingType.LEGAL]: `**Legal Review**: ${prompt}

**Legal Meeting Agenda**:
1. **Compliance Overview** (10 min)
   - Current legal standing
   - Recent regulatory changes

2. **Focus Discussion** (30 min)
   - ${prompt}
   - Legal risk assessment
   - Policy and procedure updates

3. **Documentation Review** (15 min)
   - Contract updates and amendments
   - Terms of service modifications

4. **Action Items** (5 min)
   - Legal task assignments
   - Timeline for deliverables`,

      [MeetingType.OTHER]: `**Meeting Purpose**: ${prompt}

**General Meeting Agenda**:
1. **Welcome & Introductions** (10 min)
   - Participant introductions
   - Meeting objectives overview

2. **Main Discussion** (35 min)
   - ${prompt}
   - Open discussion and brainstorming
   - Key points and considerations

3. **Summary & Next Steps** (15 min)
   - Key takeaways summary
   - Action item assignments
   - Follow-up meeting planning`,
    };

    return mockAgendas[meetingType] || mockAgendas[MeetingType.OTHER];
  }
}
